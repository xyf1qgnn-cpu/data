{
  "id": "snapshot_1767778543482_aioxsqc3v",
  "approvalId": "approval_1767778053972_ktljlu936",
  "approvalTitle": "需求文档: PDF缓存处理优化",
  "version": 2,
  "timestamp": "2026-01-07T09:35:43.482Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# 需求文档: PDF缓存处理优化\n\n## 引言\n\n### 概述\n当前PDF处理流程直接将提取的图片编码为base64并调用API，缺乏中间缓存机制。本需求旨在通过引入缓存机制，将PDF处理流程拆分为两阶段（图片提取 + API调用），提升处理可靠性并支持失败重试。\n\n### 价值\n- **可靠性提升**: API调用失败后可从缓存重试，无需重新提取图片\n- **日志优化**: 移除日志中的base64编码，提升日志可读性\n- **数据归档**: 自动将提取的图片归档到指定位置，便于后续使用\n- **代码简化**: 移除过时的智能筛选功能，降低维护成本\n\n## 需求\n\n### 需求1: 优化日志输出\n\n**用户故事**: 作为运维人员，我希望日志不包含base64编码内容，以便快速定位问题\n\n#### 验收标准\n\n1. WHEN 调用 `call_vision_api` 记录payload日志 THEN 日志应显示图片数量而非实际base64内容\n2. WHEN 记录API响应日志 AND 响应内容超过1000字符 THEN 日志应只显示前500字符+\"...\"\n3. WHEN 响应内容少于1000字符 THEN 日志应显示完整内容\n4. WHEN 记录payload日志 THEN 日志应包含模型名称、图片数量、max_token参数\n\n### 需求2: 支持两阶段PDF处理模式\n\n**用户故事**: 作为开发者，我希望能将PDF处理分离为图片提取和API调用两个阶段，以便实现失败重试\n\n#### 验收标准\n\n1. WHEN `process_pdf` 以 mode=\"full\" 调用 THEN 函数应完整处理PDF（保持向后兼容）\n2. WHEN `process_pdf` 以 mode=\"extract_only\" 调用 THEN 函数应返回cache目录和图片列表\n3. WHEN `process_pdf` 解析PDF时 AND PDF页数大于1 THEN 应处理除最后一页外的所有页面\n4. WHEN `process_pdf` 以 mode=\"extract_only\" 调用完成 THEN 图片应保存到 `./cache/{pdf_name}/` 目录\n5. WHEN 图片保存到cache时 THEN应保存为JPEG格式，质量设置为95\n\n### 需求3: 实现缓存处理函数\n\n**用户故事**: 作为开发者，我希望能够从缓存中读取图片并调用API，以便在API失败时重试\n\n#### 验收标准\n\n1. GIVEN cache目录和图片路径列表 WHEN调用`process_from_cache` THEN 函数应返回API调用结果\n2. WHEN `process_from_cache`处理图片时 THEN 应使用JPEG格式进行base64编码\n3. WHEN `process_from_cache`调用API时 THEN 应重用现有的`encode_images_to_base64`和`call_vision_api`函数\n4. WHEN `process_from_cache`执行过程中发生错误 THEN 应记录错误日志并返回None\n\n### 需求4: 实现缓存归档功能\n\n**用户故事**: 作为数据管理员，我希望自动归档提取的图片到指定位置，以便后续分析和备份\n\n#### 验收标准\n\n1. WHEN `archive_cache`被调用 THEN 应将cache目录压缩为zip文件\n2. WHEN 创建归档时 THEN 文件名应为`{pdf_name}_images.zip`\n3. WHEN 归档完成后路径应位于 `/mnt/e/Documents/data_extracted/Dataset ({batch_number}) {YYYY-MM-DD}/`\n4. WHEN 归档成功 THEN 应删除原始cache目录以释放空间\n5. WHEN 归档失败 THEN 应保留cache目录并记录错误日志\n\n### 需求5: 更新主流程调用逻辑\n\n**用户故事**: 作为用户，我希望PDF处理流程自动执行两阶段处理并归档，无需手动干预\n\n#### 验收标准\n\n1. WHEN 处理每个PDF时 THEN 应首先调用`process_pdf`的extract_only模式提取图片\n2. WHEN 图片提取成功 THEN 应调用`process_from_cache`进行API处理\n3. WHEN API处理成功 THEN 应调用`archive_cache`归档cache\n4. WHEN 批次处理结束时 THEN 批次号应在state.json中正确递增\n5. WHEN 任何阶段失败 THEN 应将PDF移动到NotInput目录并记录失败原因\n\n### 需求6: 完善错误处理和批次管理\n\n**用户故事**: 作为运维人员，我希望在失败时能清楚知道原因，并确保批次号管理正确\n\n#### 验收标准\n\n1. WHEN `process_pdf` 失败 THEN 应记录详细错误日志包括文件名和错误原因\n2. WHEN API调用失败时 THEN 应能在不重提图片的情况下使用相同cache重试\n3. WHEN 批次号递增时 THEN 应在每个PDF成功处理后更新state.json\n4. WHEN 更新state.json时 THEN 应记录处理的PDF信息和批次号\n5. WHEN 归档失败时 THEN 应保留cache目录不影响后续处理\n\n### 需求7: 支持页数限制配置（性能优化）\n\n**用户故事**: 作为用户，我希望可以设置最大处理页数，避免处理过长PDF导致超时\n\n#### 验收标准\n\n1. WHEN PDF页数超过配置的 `max_pages` THEN 只处理前 `max_pages` 页\n2. WHEN `config.json` 中包含 `max_pages` 配置时 THEN `process_pdf` 应遵守该限制\n3. WHEN `max_pages` 未配置 THEN 默认使用最大8页（与原系统一致）\n4. WHEN 页数被限制时 THEN 日志应明确提示\"处理前N页，共M页\"\n\n### 需求8: 完善返回值设计\n\n**用户故事**: 作为开发者，我希望函数返回值格式统一，便于调用端处理\n\n#### 验收标准\n\n1. WHEN `process_pdf` 以 mode=\"extract_only\" 返回 THEN 应返回 `{\"cache_dir\": str, \"image_paths\": List[str]}`\n2. WHEN `process_pdf` 以 mode=\"full\" 返回 THEN 应返回 `{\"result\": Dict, \"cache_dir\": str}`\n3. WHEN 返回字典时 THEN 所有字段都应存在且类型正确\n4. WHEN 处理失败时 THEN 应返回None而非抛出异常\n\n### 需求9: 清理过时代码\n\n**用户故事**: 作为代码维护者，我希望移除不再使用的代码，降低维护负担\n\n#### 验收标准\n\n1. WHEN 部署完成后 THEN 应删除 `get_smart_pages_to_process` 函数\n2. WHEN 部署完成后 THEN 应删除 `config.json` 中的页面筛选相关配置\n3. WHEN 删除旧代码后 THEN 系统应仍能正常运行所有现有功能\n4. WHEN 代码清理完成 THEN 应验证所有引用都已更新\n\n### 需求10: 更新配置文件\n\n**用户故事**: 作为系统管理员，我希望配置文件中只包含有效的配置项\n\n#### 验收标准\n\n1. WHEN `config.json` 更新后 THEN 应包含 `processing_settings` 配置块\n2. WHEN `config.json` 包含 `paths` 配置 THEN 应正确定义 `archive_destination`\n3. WHEN `config.json` 完成更新后 THEN 应删除所有 `page_filtering` 相关配置\n4. WHEN 配置更新后 THEN 应用应能正确读取并使用新配置\n\n## 非功能性需求\n\n### 代码架构与模块化\n\n- **单一职责原则**: 每个函数应有清晰定义的功能，如`process_pdf`负责图片提取，`process_from_cache`负责API调用\n- **模块化设计**: 缓存处理逻辑应与PDF处理逻辑分离，便于独立测试\n- **最小化依赖**: 新功能应重用现有工具函数，避免新增依赖\n- **清晰接口**: 修改后`process_pdf`的mode参数应有明确的行为定义\n\n### 性能要求\n\n- WHEN 处理单页PDF时 THEN 缓存创建时间应小于500ms\n- WHEN 处理8页PDF时 THEN 图片编码和保存时间应小于2秒\n- WHEN zip归档大小在100MB内时 THEN 归档操作时间应小于10秒\n- WHEN API调用失败时 THEN 从cache重试的时间应仅为API调用时间，不含图片提取时间\n\n### 可靠性要求\n\n- WHEN cache目录已存在 THEN `os.makedirs(cache_dir, exist_ok=True)`不应抛出异常\n- WHEN 磁盘空间不足时 THEN 应在提取图片前检查并抛出有意义的错误提示\n- WHEN zip文件已存在时 THEN `archive_cache` 应覆盖旧文件或创建备份\n- WHEN 清理cache失败时 THEN 不应影响主流程的继续执行\n\n### 可维护性要求\n\n- WHEN 查看日志时 THEN 应能清晰识别处理的PDF名称、页数和阶段\n- WHEN 查看归档目录时 THEN 应能通过批次号和日期快速定位数据\n- WHEN 查看配置文件时 THEN 配置项应有清晰的命名和说明\n- WHEN 代码出现错误时 THEN 错误信息应包含足够的上下文帮助诊断问题\n\n### 安全性要求\n\n- WHEN 保存图片到cache时 THEN 应不能使用可执行文件名\n- WHEN 执行 `shutil.rmtree` 时 THEN 目标路径应限定在cache目录内\n- WHEN 读取cache中的图片时 THEN 应验证文件确实是图片格式\n\n### 可测试性要求\n\n- WHEN 测试 `process_from_cache` 时 THEN 应能使用模拟的cache目录和image_paths\n- WHEN 测试 `archive_cache` 时 THEN 应能指定临时的归档目标路径\n- WHEN 测试失败场景时 THEN 函数应提供清晰的错误信息而非抛出未捕获异常\n\n## 后续优化考虑\n\n### 未来可能的需求\n\n1. **增量处理**: 只处理未处理的页面\n2. **并行批处理**: 同时从多个cache调用API\n3. **Cache清理策略**: 基于时间或空间的自动清理\n4. **处理进度恢复**: 从中断处继续处理\n5. **图片格式选项**: 支持PNG、WebP等格式\n\n## 参考资料\n\n- 实施计划核心版: `/home/thelya/Work/data/实施计划_核心版.md`\n- 审查结果: `/home/thelya/Work/data/实施计划_核心版_Review结果.md`\n- 实现原则: 最小化新增代码，最大化复用现有函数\n",
  "fileStats": {
    "size": 8782,
    "lines": 187,
    "lastModified": "2026-01-07T09:26:08.891Z"
  },
  "comments": []
}